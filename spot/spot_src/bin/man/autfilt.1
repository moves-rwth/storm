.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.
.TH AUTFILT "1" "January 2021" "autfilt (spot) 2.9.6" "User Commands"
.SH NAME
autfilt \- filter, convert, and transform omega-automata
.SH SYNOPSIS
.B autfilt
[\fI\,OPTION\/\fR...] [\fI\,FILENAME\/\fR[\fI\,/COL\/\fR]...]
.SH DESCRIPTION
.\" Add any additional description here
.PP
Convert, transform, and filter omega\-automata.
.SS "Input:"
.TP
\fB\-F\fR, \fB\-\-file\fR=\fI\,FILENAME\/\fR
process the automaton in FILENAME
.TP
\fB\-\-trust\-hoa\fR=\fI\,BOOL\/\fR
If false, properties listed in HOA files are
ignored, unless they can be easily verified.  If
true (the default) any supported property is
trusted.
.SS "Output automaton type:"
.TP
\fB\-B\fR, \fB\-\-ba\fR
Büchi Automaton (with state\-based acceptance)
.TP
\fB\-\-cobuchi\fR, \fB\-\-coBuchi\fR
automaton with co\-Büchi acceptance (will
recognize a superset of the input language if not
co\-Büchi realizable)
.TP
\fB\-C\fR, \fB\-\-complete\fR
output a complete automaton
.TP
\fB\-G\fR, \fB\-\-generic\fR
any acceptance is allowed (default)
.TP
\fB\-M\fR, \fB\-\-monitor\fR
Monitor (accepts all finite prefixes of the given
property)
.HP
\fB\-p\fR, \fB\-\-colored\-parity\fR[\fI\,\/\fR=\fI\,any\/\fR|\fI\,min\/\fR|\fI\,max\/\fR|\fI\,odd\/\fR|\fI\,even\/\fR|\fI\,min\/\fR odd|min even|max odd|max
.TP
even]
colored automaton with parity acceptance
.TP
\fB\-P\fR, \fB\-\-parity\fR[\fI\,\/\fR=\fI\,any\/\fR|\fI\,min\/\fR|\fI\,max\/\fR|\fI\,odd\/\fR|\fI\,even\/\fR|\fI\,min\/\fR odd|min even|max odd|max even]
automaton with parity acceptance
.TP
\fB\-S\fR, \fB\-\-state\-based\-acceptance\fR, \fB\-\-sbacc\fR
define the acceptance using states
.TP
\fB\-\-tgba\fR
Transition\-based Generalized Büchi Automaton
.SS "Output format:"
.TP
\fB\-8\fR, \fB\-\-utf8\fR
enable UTF\-8 characters in output (ignored with
\fB\-\-lbtt\fR or \fB\-\-spin\fR)
.TP
\fB\-c\fR, \fB\-\-count\fR
print only a count of matched automata
.TP
\fB\-\-check\fR[=\fI\,PROP\/\fR]
test for the additional property PROP and output
the result in the HOA format (implies \fB\-H\fR).  PROP
may be some prefix of 'all' (default),
\&'unambiguous', 'stutter\-invariant',
\&'stutter\-sensitive\-example', 'semi\-determinism',
or 'strength'.
.TP
\fB\-d\fR, \fB\-\-dot\fR[=\fI\,1\/\fR|\:\fI\,a\/\fR|\:\fI\,A\/\fR|\:\fI\,b\/\fR|\:\fI\,B\/\fR|\:\fI\,c\/\fR|\:\fI\,C(COLOR)\/\fR|\:\fI\,e\/\fR|\:\fI\,E\/\fR|\:\fI\,f(FONT)\/\fR|\:\fI\,h\/\fR|\:\fI\,k\/\fR|\:\fI\,K\/\fR|\:\fI\,n\/\fR|\:\fI\,N\/\fR|\:\fI\,o\/\fR|\:\fI\,r\/\fR|\:\fI\,R\/\fR|\:\fI\,s\/\fR|\:\fI\,t\/\fR|\:\fI\,u\/\fR|\:\fI\,v\/\fR|\:\fI\,y\/\fR|\:\fI\,+INT\/\fR|\:\fI\,<INT\/\fR|\:\fI\,#\/\fR]
GraphViz's format.  Add letters for (1) force
numbered states, (a) show acceptance condition
(default), (A) hide acceptance condition, (b)
acceptance sets as bullets, (B) bullets except for
Büchi/co\-Büchi automata, (c) force circular
nodes, (C) color nodes with COLOR, (d) show
origins when known, (e) force elliptic nodes, (E)
force rEctangular nodes, (f(FONT)) use FONT, (g)
hide edge labels, (h) horizontal layout, (k) use
state labels when possible, (K) use transition
labels (default), (n) show name, (N) hide name,
(o) ordered transitions, (r) rainbow colors for
acceptance sets, (R) color acceptance sets by
Inf/Fin, (s) with SCCs, (t) force transition\-based
acceptance, (u) hide true states, (v) vertical
layout, (y) split universal edges by color, (+INT)
add INT to all set numbers, (<INT) display at most
INT states, (#) show internal edge numbers
.TP
\fB\-H\fR, \fB\-\-hoaf\fR[=\fI\,1.1\/\fR|\:\fI\,i\/\fR|\:\fI\,k\/\fR|\:\fI\,l\/\fR|\:\fI\,m\/\fR|\:\fI\,s\/\fR|\:\fI\,t\/\fR|\:\fI\,v\/\fR]
Output the automaton in HOA format
(default).  Add letters to select (1.1) version
1.1 of the format, (i) use implicit labels for
complete deterministic automata, (s) prefer
state\-based acceptance when possible [default],
(t) force transition\-based acceptance, (m) mix
state and transition\-based acceptance, (k) use
state labels when possible, (l) single\-line
output, (v) verbose properties
.TP
\fB\-\-lbtt\fR[=\fI\,t\/\fR]
LBTT's format (add =t to force transition\-based
acceptance even on Büchi automata)
.TP
\fB\-n\fR, \fB\-\-max\-count\fR=\fI\,NUM\/\fR
output at most NUM automata
.TP
\fB\-\-name\fR=\fI\,FORMAT\/\fR
set the name of the output automaton
.TP
\fB\-o\fR, \fB\-\-output\fR=\fI\,FORMAT\/\fR
send output to a file named FORMAT instead of
standard output.  The first automaton sent to a
file truncates it unless FORMAT starts with '>>'.
.TP
\fB\-q\fR, \fB\-\-quiet\fR
suppress all normal output
.TP
\fB\-s\fR, \fB\-\-spin\fR[=\fI\,6\/\fR|\:\fI\,c\/\fR]
Spin neverclaim (implies \fB\-\-ba\fR).  Add letters to
select (6) Spin's 6.2.4 style, (c) comments on
states
.TP
\fB\-\-stats\fR=\fI\,FORMAT\/\fR, \fB\-\-format\fR=\fI\,FORMAT\/\fR
output statistics about the automaton
.PP
Any FORMAT string may use the following interpreted sequences (capitals for
input, minuscules for output):
.TP
%%
a single %
.TP
%<
the part of the line before the automaton if it
comes from a column extracted from a CSV file
.TP
%>
the part of the line after the automaton if it
comes from a column extracted from a CSV file
.TP
%A, %a
number of acceptance sets
.TP
%C, %c, %[LETTERS]C, %[LETTERS]c
number of SCCs; you may filter the SCCs to count
using the following LETTERS, possibly
concatenated: (a) accepting, (r) rejecting, (c)
complete, (v) trivial, (t) terminal, (w) weak,
(iw) inherently weak. Use uppercase letters to
negate them.
.TP
%D, %d
1 if the automaton is deterministic, 0 otherwise
.TP
%E, %e
number of reachable edges
.TP
%F
name of the input file
.TP
%G, %g, %[LETTERS]G, %[LETTERS]g
acceptance condition (in HOA syntax); add brackets
to print an acceptance name instead and LETTERS to
tweak the format: (0) no parameters, (a)
accentuated, (b) abbreviated, (d) style used in
dot output, (g) no generalized parameter, (l)
recognize Street\-like and Rabin\-like, (m) no main
parameter, (p) no parity parameter, (o) name
unknown acceptance as 'other', (s) shorthand for
\&'lo0'.
.TP
%H, %h
the automaton in HOA format on a single line (use
%[opt]H or %[opt]h to specify additional options
as in \fB\-\-hoa\fR=\fI\,opt)\/\fR
.TP
%L
location in the input file
.TP
%M, %m
name of the automaton
.TP
%N, %n
number of nondeterministic states
.TP
%P, %p
1 if the automaton is complete, 0 otherwise
.TP
%r
wall\-clock time elapsed in seconds (excluding
parsing)
.TP
%R, %[LETTERS]R
CPU time (excluding parsing), in seconds; Add
LETTERS to restrict to(u) user time, (s) system
time, (p) parent process, or (c) children
processes.
.TP
%S, %s
number of reachable states
.TP
%T, %t
number of reachable transitions
.TP
%U, %u, %[LETTER]U, %[LETTER]u
1 if the automaton contains some universal
.TP
branching (or a number of [s]tates or [e]dges with
universal branching)
.TP
%W, %w
one word accepted by the automaton
.TP
%X, %x, %[LETTERS]X, %[LETTERS]x
number of atomic propositions declared in the
automaton;  add LETTERS to list atomic
propositions with (n) no quoting, (s) occasional
double\-quotes with C\-style escape, (d)
double\-quotes with C\-style escape, (c)
double\-quotes with CSV\-style escape, (p) between
parentheses, any extra non\-alphanumeric character
will be used to separate propositions
.SS "Filtering options:"
.TP
\fB\-\-acc\-sccs\fR=\fI\,RANGE\/\fR, \fB\-\-accepting\-sccs\fR=\fI\,RANGE\/\fR
keep automata whose number of non\-trivial
accepting SCCs is in RANGE
.TP
\fB\-\-acc\-sets\fR=\fI\,RANGE\/\fR
keep automata whose number of acceptance sets is
in RANGE
.TP
\fB\-\-accept\-word\fR=\fI\,WORD\/\fR
keep automata that accept WORD
.TP
\fB\-\-acceptance\-is\fR=\fI\,NAME\/\fR|\fI\,FORMULA\/\fR
match automata with given acceptance condition
.TP
\fB\-\-ap\fR=\fI\,RANGE\/\fR
match automata with a number of (declared) atomic
propositions in RANGE
.TP
\fB\-\-are\-isomorphic\fR=\fI\,FILENAME\/\fR
keep automata that are isomorphic to the
automaton in FILENAME
.TP
\fB\-\-edges\fR=\fI\,RANGE\/\fR
keep automata whose number of edges is in RANGE
.TP
\fB\-\-equivalent\-to\fR=\fI\,FILENAME\/\fR
keep automata that are equivalent
(language\-wise) to the automaton in FILENAME
.TP
\fB\-\-has\-exist\-branching\fR
keep automata that use existential branching
(i.e., make non\-deterministic choices)
.TP
\fB\-\-has\-univ\-branching\fR
keep alternating automata that use universal
branching
.TP
\fB\-\-included\-in\fR=\fI\,FILENAME\/\fR keep automata whose languages are included in that
of the automaton from FILENAME
.TP
\fB\-\-inherently\-weak\-sccs\fR=\fI\,RANGE\/\fR
keep automata whose number of accepting
inherently\-weak SCCs is in RANGE.  An accepting
SCC is inherently weak if it does not have a
rejecting cycle.
.TP
\fB\-\-intersect\fR=\fI\,FILENAME\/\fR
keep automata whose languages have an non\-empty
intersection with the automaton from FILENAME
.TP
\fB\-\-is\-alternating\fR
keep only automata using universal branching
.TP
\fB\-\-is\-colored\fR
keep colored automata (i.e., exactly one
acceptance mark per transition or state)
.TP
\fB\-\-is\-complete\fR
keep complete automata
.TP
\fB\-\-is\-deterministic\fR
keep deterministic automata
.TP
\fB\-\-is\-empty\fR
keep automata with an empty language
.TP
\fB\-\-is\-inherently\-weak\fR
keep only inherently weak automata
.TP
\fB\-\-is\-semi\-deterministic\fR
keep semi\-deterministic automata
.TP
\fB\-\-is\-stutter\-invariant\fR keep automata representing stutter\-invariant
properties
.TP
\fB\-\-is\-terminal\fR
keep only terminal automata
.TP
\fB\-\-is\-unambiguous\fR
keep only unambiguous automata
.TP
\fB\-\-is\-very\-weak\fR
keep only very\-weak automata
.TP
\fB\-\-is\-weak\fR
keep only weak automata
.TP
\fB\-\-nondet\-states\fR=\fI\,RANGE\/\fR
keep automata whose number of nondeterministic
states is in RANGE
.TP
\fB\-N\fR, \fB\-\-nth\fR=\fI\,RANGE\/\fR
assuming input automata are numbered from 1, keep
only those in RANGE
.TP
\fB\-\-rej\-sccs\fR=\fI\,RANGE\/\fR, \fB\-\-rejecting\-sccs\fR=\fI\,RANGE\/\fR
keep automata whose number of non\-trivial
rejecting SCCs is in RANGE
.TP
\fB\-\-reject\-word\fR=\fI\,WORD\/\fR
keep automata that reject WORD
.TP
\fB\-\-sccs\fR=\fI\,RANGE\/\fR
keep automata whose number of SCCs is in RANGE
.TP
\fB\-\-states\fR=\fI\,RANGE\/\fR
keep automata whose number of states is in RANGE
.TP
\fB\-\-terminal\-sccs\fR=\fI\,RANGE\/\fR
keep automata whose number of accepting terminal
SCCs is in RANGE.  Terminal SCCs are weak and
complete.
.TP
\fB\-\-triv\-sccs\fR=\fI\,RANGE\/\fR, \fB\-\-trivial\-sccs\fR=\fI\,RANGE\/\fR
keep automata whose number of trivial SCCs is in
RANGE
.TP
\fB\-\-unused\-ap\fR=\fI\,RANGE\/\fR
match automata with a number of declared, but
unused atomic propositions in RANGE
.TP
\fB\-\-used\-ap\fR=\fI\,RANGE\/\fR
match automata with a number of used atomic
propositions in RANGE
.TP
\fB\-u\fR, \fB\-\-unique\fR
do not output the same automaton twice (same in
the sense that they are isomorphic)
.TP
\fB\-v\fR, \fB\-\-invert\-match\fR
select non\-matching automata
.TP
\fB\-\-weak\-sccs\fR=\fI\,RANGE\/\fR
keep automata whose number of accepting weak SCCs
is in RANGE.  In a weak SCC, all transitions
belong to the same acceptance sets.
.PP
RANGE may have one of the following forms: 'INT', 'INT..INT', '..INT', or
\&'INT..'
.PP
WORD is lasso\-shaped and written as 'BF;BF;...;BF;cycle{BF;...;BF}' where BF
are arbitrary Boolean formulas.  The 'cycle{...}' part is mandatory, but the
prefix can be omitted.
.SS "Transformations:"
.TP
\fB\-\-cleanup\-acceptance\fR
remove unused acceptance sets from the automaton
.TP
\fB\-\-cnf\-acceptance\fR
put the acceptance condition in Conjunctive Normal
Form
.TP
\fB\-\-complement\fR
complement each automaton (different strategies
are used)
.TP
\fB\-\-complement\-acceptance\fR
complement the acceptance condition (without
touching the automaton)
.TP
\fB\-\-decompose\-scc\fR=\fI\,t\/\fR|\fI\,w\/\fR|\fI\,s\/\fR|\fI\,N\/\fR|\fI\,aN\/\fR, \fB\-\-decompose\-strength\fR=\fI\,t\/\fR|\fI\,w\/\fR|\fI\,s\/\fR|\fI\,N\/\fR|\fI\,aN\/\fR
extract the (t) terminal, (w) weak, or (s) strong
part of an automaton or (N) the subautomaton
leading to the Nth SCC, or (aN) to the Nth
accepting SCC (option can be combined with commas
to extract multiple parts)
.TP
\fB\-\-destut\fR
allow less stuttering
.TP
\fB\-\-dnf\-acceptance\fR
put the acceptance condition in Disjunctive Normal
Form
.TP
\fB\-\-dualize\fR
dualize each automaton
.TP
\fB\-\-exclusive\-ap\fR=\fI\,AP\/\fR,AP,...
if any of those APs occur in the automaton,
restrict all edges to ensure two of them may not
be true at the same time.  Use this option
multiple times to declare independent groups of
exclusive propositions.
.TP
\fB\-\-generalized\-rabin\fR[=\fI\,unique\-inf\/\fR|\:\fI\,share\-inf\/\fR], \fB\-\-gra\fR[=\fI\,unique\-inf\/\fR|\:\fI\,share\-inf\/\fR]
rewrite the acceptance condition as generalized
Rabin; the default "unique\-inf" option uses the
generalized Rabin definition from the HOA format;
the "share\-inf" option allows clauses to share Inf
sets, therefore reducing the number of sets
.TP
\fB\-\-generalized\-streett\fR[=\fI\,unique\-fin\/\fR|\:\fI\,share\-fin\/\fR], \fB\-\-gsa\fR[=\fI\,unique\-fin\/\fR|\:\fI\,share\-fin\/\fR]
rewrite the acceptance condition as generalized
Streett; the "share\-fin" option allows clauses to
share Fin sets, therefore reducing the number of
sets; the default "unique\-fin" does not
.TP
\fB\-\-instut\fR[=\fI\,1\/\fR|\:\fI\,2\/\fR]
allow more stuttering (two possible algorithms)
.TP
\fB\-\-keep\-states\fR=\fI\,NUM\/\fR[\fI\,\/\fR,NUM...]
only keep specified states.  The first state
will be the new initial state.  Implies
\fB\-\-remove\-unreachable\-states\fR.
.TP
\fB\-\-mask\-acc\fR=\fI\,NUM\/\fR[\fI\,\/\fR,NUM...]
remove all transitions in specified acceptance
sets
.TP
\fB\-\-merge\-transitions\fR
merge transitions with same destination and
acceptance
.TP
\fB\-\-partial\-degeneralize\fR[\fI\,\/\fR=\fI\,NUM1\/\fR,NUM2,...]
Degeneralize automata according to sets
NUM1,NUM2,... If no sets are given, partial
degeneralization is performed for all conjunctions
of Inf and disjunctions of Fin.
.TP
\fB\-\-product\fR=\fI\,FILENAME\/\fR, \fB\-\-product\-and\fR=\fI\,FILENAME\/\fR
build the product with the automaton in FILENAME
to intersect languages
.TP
\fB\-\-product\-or\fR=\fI\,FILENAME\/\fR
build the product with the automaton in FILENAME
to sum languages
.TP
\fB\-\-randomize\fR[=\fI\,s\/\fR|\:\fI\,t\/\fR]
randomize states and transitions (specify 's' or
\&'t' to randomize only states or transitions)
.TP
\fB\-\-remove\-ap\fR=\fI\,AP\/\fR[\fI\,=0\/\fR|\fI\,=1\/\fR]\fI\,\/\fR[\fI\,\/\fR,AP...]
remove atomic propositions either by existential
quantification, or by assigning them 0 or 1
.TP
\fB\-\-remove\-dead\-states\fR
remove states that are unreachable, or that cannot
belong to an infinite path
.TP
\fB\-\-remove\-fin\fR
rewrite the automaton without using Fin
acceptance
.TP
\fB\-\-remove\-unreachable\-states\fR
remove states that are unreachable from the
initial state
.TP
\fB\-\-remove\-unused\-ap\fR
remove declared atomic propositions that are not
used
.TP
\fB\-\-sat\-minimize\fR[=\fI\,options\/\fR]
minimize the automaton using a SAT solver
(only works for deterministic automata). Supported
options are acc=STRING, states=N, max\-states=N,
sat\-incr=N, sat\-incr\-steps=N, sat\-langmap,
sat\-naive, colored, preproc=N. Spot uses by
default its PicoSAT distribution but an external
SATsolver can be set thanks to the SPOT_SATSOLVER
environment variable(see spot\-x).
.TP
\fB\-\-separate\-sets\fR
if both Inf(x) and Fin(x) appear in the acceptance
condition, replace Fin(x) by a new Fin(y) and
adjust the automaton
.TP
\fB\-\-simplify\-acceptance\fR
simplify the acceptance condition by merging
identical acceptance sets and by simplifying some
terms containing complementary sets
.TP
\fB\-\-simplify\-exclusive\-ap\fR
if \fB\-\-exclusive\-ap\fR is used, assume those AP
groups are actually exclusive in the system to
simplify the expression of transition labels
(implies \fB\-\-merge\-transitions\fR)
.TP
\fB\-\-split\-edges\fR
split edges into transitions labeled by
conjunctions of all atomic propositions, so they
can be read as letters
.TP
\fB\-\-streett\-like\fR
convert to an automaton with Streett\-like
acceptance. Works only with acceptance condition
in DNF
.TP
\fB\-\-strip\-acceptance\fR
remove the acceptance condition and all acceptance
sets
.TP
\fB\-\-sum\fR=\fI\,FILENAME\/\fR, \fB\-\-sum\-or\fR=\fI\,FILENAME\/\fR
build the sum with the automaton in FILENAME to
sum languages
.TP
\fB\-\-sum\-and\fR=\fI\,FILENAME\/\fR
build the sum with the automaton in FILENAME to
intersect languages
.SS "Decorations (for -d and -H1.1 output):"
.TP
\fB\-\-highlight\-accepting\-run\fR[=\fI\,NUM\/\fR]
highlight one accepting run using color NUM
.TP
\fB\-\-highlight\-languages\fR
highlight states that recognize identical
languages
.TP
\fB\-\-highlight\-nondet\fR[=\fI\,NUM\/\fR]
highlight nondeterministic states and edges
with color NUM
.TP
\fB\-\-highlight\-nondet\-edges\fR[=\fI\,NUM\/\fR]
highlight nondeterministic edges with color NUM
.TP
\fB\-\-highlight\-nondet\-states\fR[=\fI\,NUM\/\fR]
highlight nondeterministic states with color NUM
.TP
\fB\-\-highlight\-word\fR=\fI\,\/\fR[\fI\,NUM\/\fR,]WORD
highlight one run matching WORD using color NUM
.SS "Simplification goal:"
.TP
\fB\-a\fR, \fB\-\-any\fR
no preference, do not bother making it small or
deterministic
.TP
\fB\-D\fR, \fB\-\-deterministic\fR
prefer deterministic automata (combine with
\fB\-\-generic\fR to be sure to obtain a deterministic
automaton)
.TP
\fB\-\-small\fR
prefer small automata
.SS "Simplification level:"
.TP
\fB\-\-high\fR
all available optimizations (slow)
.TP
\fB\-\-low\fR
minimal optimizations (fast)
.TP
\fB\-\-medium\fR
moderate optimizations
.PP
If any option among \fB\-\-small\fR, \fB\-\-deterministic\fR, or \fB\-\-any\fR is given, then the
simplification level defaults to \fB\-\-high\fR unless specified otherwise.  If any
option among \fB\-\-low\fR, \fB\-\-medium\fR, or \fB\-\-high\fR is given, then the simplification goal
defaults to \fB\-\-small\fR unless specified otherwise.  If none of those options are
specified, then autfilt acts as is \fB\-\-any\fR \fB\-\-low\fR were given: these actually
disable the simplification routines.
.SS "Miscellaneous options:"
.TP
\fB\-\-seed\fR=\fI\,INT\/\fR
seed for the random number generator (0)
.TP
\fB\-x\fR, \fB\-\-extra\-options\fR=\fI\,OPTS\/\fR
fine\-tuning options (see spot\-x (7))
.TP
\fB\-\-help\fR
print this help
.TP
\fB\-\-version\fR
print program version
.PP
Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.
.SS "Exit status:"
.TP
0
if some automata were output
.TP
1
if no automata were output (no match)
.TP
2
if any error has been reported
.SH "OPTIONS FOR SAT\-MINIMIZATION"
.TP
\fB\fP
By default, SAT\-based minimization executes a binary search, checking N/2 etc.
The upper bound being N (the size of the starting automaton), the lower bound
is always 1 except when \fBsat-langmap\fR option is used.

.TP
\fBacc=DOUBLEQUOTEDSTRING\fP
DOUBLEQUOTEDSTRING is an acceptance formula in the HOA syntax, or a
parametrized acceptance name (the different acc\-name: options from HOA).

.TP
\fBcolored\fP
force all transitions (or all states if \fB\-S\fR is used) to belong to exactly
one acceptance condition.

.TP
\fBmax\-states=M\fP
M is an upper-bound on the maximum number of states of the constructed
automaton.

.TP
\fBsat\-incr=M\fP
use an incremental approach for SAT-based minimization algorithm. M can be
either \fB1\fR or \fB2\fR. They correspond respectively to
\fB\-x sat\-minimize=2\fR and \fB\-x sat\-minimize=3\fR options. They restart
the encoding only after (N\-1)\-\fBsat\-incr\-steps\fR states have been won.
Each iterations of both starts by encoding the research of an N\-1 automaton,
N being the size of the starting automaton. \fB1\fR uses Picosat assumptions.
It additionally assumes that the last \fBsat-incr-steps\fR states are
unnecessary. On failure, it relax the assumptions to do a binary search
between N\-1 and (N\-1)\-\fBsat-incr-steps\fR. \fBsat-incr-steps\fR defaults
to 6. \fB2\fR, as for it, after an N-1 state automaton has been found, uses
incremental solving for the next \fBsat\-incr\-steps\fR iterations by forbidding
the usage of an additional state without reencoding the problem again. A full
encoding occurs after \fBsat\-incr\-steps\fR iterations unless
\fBsat\-incr\-steps=\-1\fR (see SPOT_XCNF environment variable described in
spot\-x). It defaults to 2.

.TP
\fBsat\-incr\-steps=M\fP
set the value of \fBsat\-incr\-steps\fR to M. This is used by \fBsat\-incr\fR
option.

.TP
\fBsat-naive\fP
use the naive algorithm to find a smaller automaton. It starts from N (N being
the size of the starting automaton) and then checks N\-1, N\-2, etc. until the
last successful check.

.TP
\fBsat-langmap\fP
Find the lower bound of default sat\-minimize procedure (1). This relies on the
fact that the size of the minimal automaton is at least equal to the total
number of different languages recognized by the automaton's states.

.TP
\fBstates=M\fP
M is a fixed number of states to use in the result (all the states needs
not be accessible in the result. Therefore, the output might be smaller
nonetheless). The SAT\-based procedure is just used once to synthesize
one automaton, and no further minimization is attempted.
.SH BIBLIOGRAPHY
The following papers are related to some of the transformations implemented
in autfilt.

.TP
\(bu
Etienne Renault, Alexandre Duret-Lutz, Fabrice Kordon, and Denis Poitrenaud:
Strength-based decomposition of the property Büchi automaton for faster
model checking. Proceedings of TACAS'13. LNCS 7795.

The \fB\-\-strength\-decompose\fR option implements the definitions
given in the above paper.
.TP
\(bu
František Blahoudek, Alexandre Duret-Lutz, Vojtčech Rujbr, and Jan Strejček:
On refinement of Büchi automata for explicit model checking.
Proceedings of SPIN'15.  LNCS 9232.

That paper gives the motivation for options \fB\-\-exclusive\-ap\fR
and \fB\-\-simplify\-exclusive\-ap\fR.
.TP
\(bu
Thibaud Michaud and Alexandre Duret-Lutz:
Practical stutter-invariance checks for ω-regular languages.
Proceedings of SPIN'15.  LNCS 9232.

Describes the algorithms used by the \fB\-\-destut\fR and
\fB\-\-instut\fR options.  These options correpond respectively to
cl() and sl() in the paper.
.TP
\(bu
Souheib Baarir and Alexandre Duret-Lutz: SAT-based minimization of
deterministic ω-automata.  Proceedings of LPAR'15 (a.k.a LPAR-20).
LNCS 9450.

Describes the \fB\-\-sat\-minimize\fR option.
.SH "REPORTING BUGS"
Report bugs to <spot@lrde.epita.fr>.
.SH COPYRIGHT
Copyright \(co 2021  Laboratoire de Recherche et Développement de l'Epita.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
.br
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
.SH "SEE ALSO"
.BR spot-x (7)
.BR dstar2tgba (1)
