<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00428.html">tbb</a>::<b>interface5</b>::<a class="el" href="a00281.html">concurrent_hash_map</a></div>
<h1>tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt; Class Template Reference<br>
<small>
[<a class="el" href="a00442.html">Containers</a>]</small>
</h1><!-- doxytag: class="tbb::interface5::concurrent_hash_map" -->Unordered map from Key to T.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;concurrent_hash_map.h&gt;</code>
<p>
<a href="a00019.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e664e41a5b735a677f2ebbbcca0fcd80"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::key_type" ref="e664e41a5b735a677f2ebbbcca0fcd80" args="" -->
typedef Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="616243d5a0b6159299f2a34413e077e4"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::mapped_type" ref="616243d5a0b6159299f2a34413e077e4" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ece048b19778bc31377185392ecf312b"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::value_type" ref="ece048b19778bc31377185392ecf312b" args="" -->
typedef std::pair&lt; const Key,<br>
 T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="549109620a3331c83e46b8fe0636b883"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::size_type" ref="549109620a3331c83e46b8fe0636b883" args="" -->
typedef hash_map_base::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0a4ffc8ac85bb2eb80a4e1909a373e2c"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::difference_type" ref="0a4ffc8ac85bb2eb80a4e1909a373e2c" args="" -->
typedef ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="341d2ae1e5e9d8ba05e5306a3933f31a"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::pointer" ref="341d2ae1e5e9d8ba05e5306a3933f31a" args="" -->
typedef value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4b401731d22f457617f950416fde9bff"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::const_pointer" ref="4b401731d22f457617f950416fde9bff" args="" -->
typedef const value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2765bbab7bac8b74cfd79d269a2008b8"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::reference" ref="2765bbab7bac8b74cfd79d269a2008b8" args="" -->
typedef value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3b62b1930b2b88c98cb617f67bb9545"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::const_reference" ref="a3b62b1930b2b88c98cb617f67bb9545" args="" -->
typedef const value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="83603b64f2507ee6560133d79a001eb2"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::iterator" ref="83603b64f2507ee6560133d79a001eb2" args="" -->
typedef internal::hash_map_iterator&lt;<br>
 <a class="el" href="a00281.html">concurrent_hash_map</a>, value_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d47cbc7e0b0999b849187040f02557f5"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::const_iterator" ref="d47cbc7e0b0999b849187040f02557f5" args="" -->
typedef internal::hash_map_iterator&lt;<br>
 <a class="el" href="a00281.html">concurrent_hash_map</a>, const <br>
value_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="baeed4327d9c77f084bfb5ac8d519c96"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::range_type" ref="baeed4327d9c77f084bfb5ac8d519c96" args="" -->
typedef internal::hash_map_range&lt;<br>
 iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>range_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e7700e8872566a5dc6d1c702b7949f4"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::const_range_type" ref="1e7700e8872566a5dc6d1c702b7949f4" args="" -->
typedef internal::hash_map_range&lt;<br>
 const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_range_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf2a3ebce78da6d8be3b1803eb31a2e3"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::allocator_type" ref="bf2a3ebce78da6d8be3b1803eb31a2e3" args="" -->
typedef Allocator&nbsp;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1ad413f5b666176e7669bf4c87d1ff3f"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::concurrent_hash_map" ref="1ad413f5b666176e7669bf4c87d1ff3f" args="(const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#1ad413f5b666176e7669bf4c87d1ff3f">concurrent_hash_map</a> (const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct empty table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46b9896317662c3cfa3c876ad7592a7c"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::concurrent_hash_map" ref="46b9896317662c3cfa3c876ad7592a7c" args="(size_type n, const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#46b9896317662c3cfa3c876ad7592a7c">concurrent_hash_map</a> (size_type n, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct empty table with n preallocated buckets. This number serves also as initial concurrency level. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6fb14710893308fb47aaeee55ee30dc3"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::concurrent_hash_map" ref="6fb14710893308fb47aaeee55ee30dc3" args="(const concurrent_hash_map &amp;table, const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#6fb14710893308fb47aaeee55ee30dc3">concurrent_hash_map</a> (const <a class="el" href="a00281.html">concurrent_hash_map</a> &amp;table, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="83c40f2053f208861b90390e12a36436"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::concurrent_hash_map" ref="83c40f2053f208861b90390e12a36436" args="(I first, I last, const allocator_type &amp;a=allocator_type())" -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#83c40f2053f208861b90390e12a36436">concurrent_hash_map</a> (I first, I last, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with copying iteration range and given allocator instance. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="088d1aaccc816884a49e38f7065622c8"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::operator=" ref="088d1aaccc816884a49e38f7065622c8" args="(const concurrent_hash_map &amp;table)" -->
<a class="el" href="a00281.html">concurrent_hash_map</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#088d1aaccc816884a49e38f7065622c8">operator=</a> (const <a class="el" href="a00281.html">concurrent_hash_map</a> &amp;table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#94758113d8993cfe5afdf2d63a728869">rehash</a> (size_type n=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rehashes and optionally resizes the whole table.  <a href="#94758113d8993cfe5afdf2d63a728869"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="220686fe17b197eedf19dd856cd02e36"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::clear" ref="220686fe17b197eedf19dd856cd02e36" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#220686fe17b197eedf19dd856cd02e36">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2aa8e2d28d5af1284cf78d20a9c22731"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::~concurrent_hash_map" ref="2aa8e2d28d5af1284cf78d20a9c22731" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#2aa8e2d28d5af1284cf78d20a9c22731">~concurrent_hash_map</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear table and destroy it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee6b69f390111c92318a85600dd9c559"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::range" ref="ee6b69f390111c92318a85600dd9c559" args="(size_type grainsize=1)" -->
range_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d9a834a345415581bd801647945ea96b"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::range" ref="d9a834a345415581bd801647945ea96b" args="(size_type grainsize=1) const " -->
const_range_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="35a8c373fc3d52099ae18f0553162491"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::begin" ref="35a8c373fc3d52099ae18f0553162491" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67c50bddda53b9a10318f8981e4fc4fa"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::end" ref="67c50bddda53b9a10318f8981e4fc4fa" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c8ad3d9bb833063b3d09164199b8f7de"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::begin" ref="c8ad3d9bb833063b3d09164199b8f7de" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="75e7c0fb6addae180b6cc483b771fded"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::end" ref="75e7c0fb6addae180b6cc483b771fded" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8262e9ef1208a39e7ea087487fbe8368"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::equal_range" ref="8262e9ef1208a39e7ea087487fbe8368" args="(const Key &amp;key)" -->
std::pair&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b94bf1d3724f26299640e8b82787a75c"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::equal_range" ref="b94bf1d3724f26299640e8b82787a75c" args="(const Key &amp;key) const " -->
std::pair&lt; const_iterator,<br>
 const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6aa56a8b5a25e61a97fa0b54fe2b5659"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::size" ref="6aa56a8b5a25e61a97fa0b54fe2b5659" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#6aa56a8b5a25e61a97fa0b54fe2b5659">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of items in table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="61ff2e5bb44e5469366fd5295e5d0ebe"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::empty" ref="61ff2e5bb44e5469366fd5295e5d0ebe" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#61ff2e5bb44e5469366fd5295e5d0ebe">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if <a class="el" href="a00281.html#6aa56a8b5a25e61a97fa0b54fe2b5659">size()</a>==0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2bce57fe9b594abe1e6d2568aea8b357"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::max_size" ref="2bce57fe9b594abe1e6d2568aea8b357" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#2bce57fe9b594abe1e6d2568aea8b357">max_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upper bound on size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af34cb91b1d0f36a885a1a3432dd9af1"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::bucket_count" ref="af34cb91b1d0f36a885a1a3432dd9af1" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#af34cb91b1d0f36a885a1a3432dd9af1">bucket_count</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current number of buckets. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6cbcacb4a256a85bf89576c101373ca7"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::get_allocator" ref="6cbcacb4a256a85bf89576c101373ca7" args="() const " -->
allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#6cbcacb4a256a85bf89576c101373ca7">get_allocator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return allocator object <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="076f8d9e16110aac5f558777aa744eb6"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::swap" ref="076f8d9e16110aac5f558777aa744eb6" args="(concurrent_hash_map &amp;table)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#076f8d9e16110aac5f558777aa744eb6">swap</a> (<a class="el" href="a00281.html">concurrent_hash_map</a> &amp;table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">swap two instances. Iterators are invalidated <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6968eb6feed2df36be421df0464297af"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::count" ref="6968eb6feed2df36be421df0464297af" args="(const Key &amp;key) const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#6968eb6feed2df36be421df0464297af">count</a> (const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return count of items (0 or 1). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#2afcc33dade7bb24e008d60c0df38230">find</a> (<a class="el" href="a00284.html">const_accessor</a> &amp;result, const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find item and acquire a read lock on the item.  <a href="#2afcc33dade7bb24e008d60c0df38230"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#7bc475d1968f7f0af3d736d7e8a0d7df">find</a> (<a class="el" href="a00282.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find item and acquire a write lock on the item.  <a href="#7bc475d1968f7f0af3d736d7e8a0d7df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#47fe0e60151a9bd7a444db827772a4e6">insert</a> (<a class="el" href="a00284.html">const_accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item (if not already present) and acquire a read lock on the item.  <a href="#47fe0e60151a9bd7a444db827772a4e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#54e0955ecd11575b4c07166838a72893">insert</a> (<a class="el" href="a00282.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item (if not already present) and acquire a write lock on the item.  <a href="#54e0955ecd11575b4c07166838a72893"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#091efd2d12fdad4fe9e54d9629a9dfc3">insert</a> (<a class="el" href="a00284.html">const_accessor</a> &amp;result, const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a read lock on the item.  <a href="#091efd2d12fdad4fe9e54d9629a9dfc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#39183d78d6e8425917555ab542ab92de">insert</a> (<a class="el" href="a00282.html">accessor</a> &amp;result, const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a write lock on the item.  <a href="#39183d78d6e8425917555ab542ab92de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#3f121a316af8135de476a30fae6d7c07">insert</a> (const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already.  <a href="#3f121a316af8135de476a30fae6d7c07"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1dd37fad87e561151ba1e242ca94bcc1"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::insert" ref="1dd37fad87e561151ba1e242ca94bcc1" args="(I first, I last)" -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#1dd37fad87e561151ba1e242ca94bcc1">insert</a> (I first, I last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert range [first, last). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#f27802b3a8d1863c29e743e9c6b4e870">erase</a> (const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item.  <a href="#f27802b3a8d1863c29e743e9c6b4e870"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#e698ef3d70b2d1a29a7a5551784d3653">erase</a> (<a class="el" href="a00284.html">const_accessor</a> &amp;item_accessor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item by <a class="el" href="a00284.html">const_accessor</a>.  <a href="#e698ef3d70b2d1a29a7a5551784d3653"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#5f12d150d421420965db07368666a84f">erase</a> (<a class="el" href="a00282.html">accessor</a> &amp;item_accessor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item by accessor.  <a href="#5f12d150d421420965db07368666a84f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2066e7e0fec7813db8fe9c8b9368c9e5"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::node_allocator_type" ref="2066e7e0fec7813db8fe9c8b9368c9e5" args="" -->
typedef Allocator::template <br>
rebind&lt; node &gt;::other&nbsp;</td><td class="memItemRight" valign="bottom"><b>node_allocator_type</b></td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="559190b7953177b4967a3312f557318f"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::delete_node" ref="559190b7953177b4967a3312f557318f" args="(node_base *n)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>delete_node</b> (node_base *n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="32ec82223d843f1c2b95fa37acb7f4bb"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::search_bucket" ref="32ec82223d843f1c2b95fa37acb7f4bb" args="(const key_type &amp;key, bucket *b) const " -->
node *&nbsp;</td><td class="memItemRight" valign="bottom"><b>search_bucket</b> (const key_type &amp;key, bucket *b) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4962c7da24793ccc05524cc3bbcf1efa"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::rehash_bucket" ref="4962c7da24793ccc05524cc3bbcf1efa" args="(bucket *b_new, const hashcode_t h)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rehash_bucket</b> (bucket *b_new, const hashcode_t h)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f3413264a99174a224ef96f6c4ea769"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::lookup" ref="3f3413264a99174a224ef96f6c4ea769" args="(bool op_insert, const Key &amp;key, const T *t, const_accessor *result, bool write)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#3f3413264a99174a224ef96f6c4ea769">lookup</a> (bool op_insert, const Key &amp;key, const T *t, <a class="el" href="a00284.html">const_accessor</a> *result, bool write)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert or find item and optionally acquire a lock on the item. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c964214eb38f54603aa75fdff6d2709"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::exclude" ref="0c964214eb38f54603aa75fdff6d2709" args="(const_accessor &amp;item_accessor)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#0c964214eb38f54603aa75fdff6d2709">exclude</a> (<a class="el" href="a00284.html">const_accessor</a> &amp;item_accessor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">delete item by accessor <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="8f5373b8e1864619d1ffcf3bf3f1f13d"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::internal_equal_range" ref="8f5373b8e1864619d1ffcf3bf3f1f13d" args="(const Key &amp;key, I end) const " -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; I, I &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#8f5373b8e1864619d1ffcf3bf3f1f13d">internal_equal_range</a> (const Key &amp;key, I end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator for an item defined by the key, or for the next item after it (if upper==true). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="72c9c9e9655fcf096f5f0ed9c8ba6669"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::internal_copy" ref="72c9c9e9655fcf096f5f0ed9c8ba6669" args="(const concurrent_hash_map &amp;source)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#72c9c9e9655fcf096f5f0ed9c8ba6669">internal_copy</a> (const <a class="el" href="a00281.html">concurrent_hash_map</a> &amp;source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy "source" to *this, where *this must start out empty. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1ec1fe8dfa2d7894bf0589bfdbcb1f96"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::internal_copy" ref="1ec1fe8dfa2d7894bf0589bfdbcb1f96" args="(I first, I last)" -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>internal_copy</b> (I first, I last)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html#2f76ed101a0ccc8875b846c2f747897e">internal_fast_find</a> (const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast find when no concurrent erasure is used. For internal use inside TBB only!  <a href="#2f76ed101a0ccc8875b846c2f747897e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a72cb6e9873e5541295682179e5a7f74"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::my_allocator" ref="a72cb6e9873e5541295682179e5a7f74" args="" -->
node_allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>my_allocator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="53c747a3f2d2d2c85aec866e19c31c29"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::my_hash_compare" ref="53c747a3f2d2d2c85aec866e19c31c29" args="" -->
HashCompare&nbsp;</td><td class="memItemRight" valign="bottom"><b>my_hash_compare</b></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e24acd2f6849db3377a3942807639758"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::internal::hash_map_iterator" ref="e24acd2f6849db3377a3942807639758" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::hash_map_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c94f21746c8902f7e0b5115a8d4da1d2"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::internal::hash_map_range" ref="c94f21746c8902f7e0b5115a8d4da1d2" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::hash_map_range</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c0028dfa75a6baa14007355ab1ef7fc"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::const_accessor" ref="2c0028dfa75a6baa14007355ab1ef7fc" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_accessor</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html">accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows write access to elements and combines data access, locking, and garbage collection.  <a href="a00282.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00283.html">bucket_accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bucket accessor is to find, rehash, acquire a lock, and access a bucket  <a href="a00283.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00284.html">const_accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines data access, locking, and garbage collection.  <a href="a00284.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt;<br>
 class tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</h3>

Unordered map from Key to T. 
<p>
<a class="el" href="a00281.html">concurrent_hash_map</a> is associative container with concurrent access.<p>
<dl compact><dt><b>Compatibility</b></dt><dd>The class meets all Container Requirements from C++ Standard (See ISO/IEC 14882:2003(E), clause 23.1).</dd></dl>
<dl compact><dt><b>Exception Safety</b></dt><dd><ul>
<li>Hash function is not permitted to throw an exception. User-defined types Key and T are forbidden from throwing an exception in destructors.</li><li>If exception happens during <a class="el" href="a00281.html#47fe0e60151a9bd7a444db827772a4e6">insert()</a> operations, it has no effect (unless exception raised by HashCompare::hash() function during grow_segment).</li><li>If exception happens during <a class="el" href="a00281.html#088d1aaccc816884a49e38f7065622c8">operator=()</a> operation, the container can have a part of source items, and methods <a class="el" href="a00281.html#6aa56a8b5a25e61a97fa0b54fe2b5659">size()</a> and <a class="el" href="a00281.html#61ff2e5bb44e5469366fd5295e5d0ebe">empty()</a> can return wrong results.</li></ul>
</dd></dl>
<dl compact><dt><b>Changes since TBB 2.1</b></dt><dd><ul>
<li>Replaced internal algorithm and data structure. Patent is pending.</li><li>Added buckets number argument for constructor</li></ul>
</dd></dl>
<dl compact><dt><b>Changes since TBB 2.0</b></dt><dd><ul>
<li>Fixed exception-safety</li><li>Added template argument for allocator</li><li>Added allocator argument in constructors</li><li>Added constructor from a range of iterators</li><li>Added several new overloaded <a class="el" href="a00281.html#47fe0e60151a9bd7a444db827772a4e6">insert()</a> methods</li><li>Added <a class="el" href="a00281.html#6cbcacb4a256a85bf89576c101373ca7">get_allocator()</a></li><li>Added <a class="el" href="a00281.html#076f8d9e16110aac5f558777aa744eb6">swap()</a></li><li>Added <a class="el" href="a00281.html#6968eb6feed2df36be421df0464297af">count()</a></li><li>Added overloaded <a class="el" href="a00281.html#5f12d150d421420965db07368666a84f">erase(accessor &amp;)</a> and <a class="el" href="a00281.html#e698ef3d70b2d1a29a7a5551784d3653">erase(const_accessor&amp;)</a></li><li>Added equal_range() [const]</li><li>Added [const_]pointer, [const_]reference, and allocator_type types</li><li>Added global functions: operator==(), operator!=(), and <a class="el" href="a00281.html#076f8d9e16110aac5f558777aa744eb6">swap()</a> </li></ul>
</dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5f12d150d421420965db07368666a84f"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::erase" ref="5f12d150d421420965db07368666a84f" args="(accessor &amp;item_accessor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00282.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item_accessor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase item by accessor. 
<p>
Return true if item was erased by particularly this call. 
</div>
</div><p>
<a class="anchor" name="e698ef3d70b2d1a29a7a5551784d3653"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::erase" ref="e698ef3d70b2d1a29a7a5551784d3653" args="(const_accessor &amp;item_accessor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00284.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item_accessor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase item by <a class="el" href="a00284.html">const_accessor</a>. 
<p>
Return true if item was erased by particularly this call. 
</div>
</div><p>
<a class="anchor" name="f27802b3a8d1863c29e743e9c6b4e870"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::erase" ref="f27802b3a8d1863c29e743e9c6b4e870" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase item. 
<p>
Return true if item was erased by particularly this call. 
</div>
</div><p>
<a class="anchor" name="7bc475d1968f7f0af3d736d7e8a0d7df"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::find" ref="7bc475d1968f7f0af3d736d7e8a0d7df" args="(accessor &amp;result, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00282.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find item and acquire a write lock on the item. 
<p>
Return true if item is found, false otherwise. 
</div>
</div><p>
<a class="anchor" name="2afcc33dade7bb24e008d60c0df38230"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::find" ref="2afcc33dade7bb24e008d60c0df38230" args="(const_accessor &amp;result, const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00284.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find item and acquire a read lock on the item. 
<p>
Return true if item is found, false otherwise. 
</div>
</div><p>
<a class="anchor" name="3f121a316af8135de476a30fae6d7c07"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::insert" ref="3f121a316af8135de476a30fae6d7c07" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item by copying if there is no such key present already. 
<p>
Returns true if item is inserted. 
</div>
</div><p>
<a class="anchor" name="39183d78d6e8425917555ab542ab92de"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::insert" ref="39183d78d6e8425917555ab542ab92de" args="(accessor &amp;result, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00282.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item by copying if there is no such key present already and acquire a write lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="091efd2d12fdad4fe9e54d9629a9dfc3"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::insert" ref="091efd2d12fdad4fe9e54d9629a9dfc3" args="(const_accessor &amp;result, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00284.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item by copying if there is no such key present already and acquire a read lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="54e0955ecd11575b4c07166838a72893"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::insert" ref="54e0955ecd11575b4c07166838a72893" args="(accessor &amp;result, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00282.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item (if not already present) and acquire a write lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="47fe0e60151a9bd7a444db827772a4e6"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::insert" ref="47fe0e60151a9bd7a444db827772a4e6" args="(const_accessor &amp;result, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00284.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item (if not already present) and acquire a read lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="2f76ed101a0ccc8875b846c2f747897e"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::internal_fast_find" ref="2f76ed101a0ccc8875b846c2f747897e" args="(const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::internal_fast_find           </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fast find when no concurrent erasure is used. For internal use inside TBB only! 
<p>
Return pointer to item with given key, or NULL if no such item exists. Must not be called concurrently with erasure operations. 
</div>
</div><p>
<a class="anchor" name="94758113d8993cfe5afdf2d63a728869"></a><!-- doxytag: member="tbb::interface5::concurrent_hash_map::rehash" ref="94758113d8993cfe5afdf2d63a728869" args="(size_type n=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00281.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::rehash           </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rehashes and optionally resizes the whole table. 
<p>
Useful to optimize performance before or after concurrent operations. Also enables using of <a class="el" href="a00281.html#2afcc33dade7bb24e008d60c0df38230">find()</a> and <a class="el" href="a00281.html#6968eb6feed2df36be421df0464297af">count()</a> concurrent methods in serial context. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>concurrent_hash_map.h</ul>
<hr>
<p></p>
Copyright &copy; 2005-2013 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
