From 0abc53ff977a201cccfc07dc9a573204e86330d4 Mon Sep 17 00:00:00 2001
From: Tim Quatmann <tim.quatmann@cs.rwth-aachen.de>
Date: Wed, 25 Feb 2026 11:01:00 +0100
Subject: [PATCH] Storm patch

---
 Eigen/src/SparseLU/SparseLU.h              | 12 ++--
 Eigen/src/SparseLU/SparseLU_column_bmod.h  |  2 +-
 Eigen/src/SparseLU/SparseLU_copy_to_ucol.h |  2 +-
 Eigen/src/SparseLU/SparseLU_panel_bmod.h   |  6 +-
 Eigen/src/SparseLU/SparseLU_pivotL.h       | 68 +++++++++++++++-------
 5 files changed, 59 insertions(+), 31 deletions(-)

diff --git a/Eigen/src/SparseLU/SparseLU.h b/Eigen/src/SparseLU/SparseLU.h
index cc69a42de..49c3ecd1f 100644
--- a/Eigen/src/SparseLU/SparseLU.h
+++ b/Eigen/src/SparseLU/SparseLU.h
@@ -176,7 +176,7 @@ class SparseLU : public SparseSolverBase<SparseLU<MatrixType_, OrderingType_>>,
    * Construct a SparseLU. As no matrix is given as argument, compute() should be called afterward with a matrix.
    */
   SparseLU()
-      : m_lastError(""), m_Ustore(0, 0, 0, 0, 0, 0), m_symmetricmode(false), m_diagpivotthresh(1.0), m_detPermR(1) {
+      : m_lastError(""), m_Ustore(0, 0, 0, 0, 0, 0), m_symmetricmode(false), m_diagpivotthresh(1), m_detPermR(1) {
     initperfvalues();
   }
   /** \brief Constructor of the solver already based on a specific matrix.
@@ -184,7 +184,7 @@ class SparseLU : public SparseSolverBase<SparseLU<MatrixType_, OrderingType_>>,
    * Construct a SparseLU. compute() is already called with the given matrix.
    */
   explicit SparseLU(const MatrixType& matrix)
-      : m_lastError(""), m_Ustore(0, 0, 0, 0, 0, 0), m_symmetricmode(false), m_diagpivotthresh(1.0), m_detPermR(1) {
+      : m_lastError(""), m_Ustore(0, 0, 0, 0, 0, 0), m_symmetricmode(false), m_diagpivotthresh(1), m_detPermR(1) {
     initperfvalues();
     compute(matrix);
   }
@@ -372,7 +372,7 @@ class SparseLU : public SparseSolverBase<SparseLU<MatrixType_, OrderingType_>>,
     using std::abs;
     eigen_assert(m_factorizationIsOk && "The matrix should be factorized first.");
     // Initialize with the determinant of the row matrix
-    Scalar det = Scalar(1.);
+    Scalar det = Scalar(1);
     // Note that the diagonal blocks of U are stored in supernodes,
     // which are available in the  L part :)
     for (Index j = 0; j < this->cols(); ++j) {
@@ -401,7 +401,7 @@ class SparseLU : public SparseSolverBase<SparseLU<MatrixType_, OrderingType_>>,
     using std::log;
 
     eigen_assert(m_factorizationIsOk && "The matrix should be factorized first.");
-    Scalar det = Scalar(0.);
+    Scalar det = Scalar(0);
     for (Index j = 0; j < this->cols(); ++j) {
       for (typename SCMatrix::InnerIterator it(m_Lstore, j); it; ++it) {
         if (it.row() < j) continue;
@@ -449,7 +449,7 @@ class SparseLU : public SparseSolverBase<SparseLU<MatrixType_, OrderingType_>>,
   Scalar determinant() {
     eigen_assert(m_factorizationIsOk && "The matrix should be factorized first.");
     // Initialize with the determinant of the row matrix
-    Scalar det = Scalar(1.);
+    Scalar det = Scalar(1);
     // Note that the diagonal blocks of U are stored in supernodes,
     // which are available in the  L part :)
     for (Index j = 0; j < this->cols(); ++j) {
@@ -841,7 +841,7 @@ struct SparseLUMatrixLReturnType : internal::no_assignment_operator {
     SparseMatrix<Scalar, ColMajor, Index> sL(rows(), cols());
     sL.reserve(colCount);
     for (Index i = 0; i < cols(); i++) {
-      sL.insert(i, i) = 1.0;
+      sL.insert(i, i) = 1;
       typename MappedSupernodalType::InnerIterator iter(m_mapL, i);
       for (; iter; ++iter) {
         if (iter.row() > iter.col()) {
diff --git a/Eigen/src/SparseLU/SparseLU_column_bmod.h b/Eigen/src/SparseLU/SparseLU_column_bmod.h
index 8435b5622..db89b8ffa 100644
--- a/Eigen/src/SparseLU/SparseLU_column_bmod.h
+++ b/Eigen/src/SparseLU/SparseLU_column_bmod.h
@@ -127,7 +127,7 @@ Index SparseLUImpl<Scalar, StorageIndex>::column_bmod(const Index jcol, const In
   for (isub = glu.xlsub(fsupc); isub < glu.xlsub(fsupc + 1); isub++) {
     irow = glu.lsub(isub);
     glu.lusup(nextlu) = dense(irow);
-    dense(irow) = Scalar(0.0);
+    dense(irow) = Scalar(0);
     ++nextlu;
   }
 
diff --git a/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h b/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h
index 12e7650c4..af56a1cc7 100644
--- a/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h
+++ b/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h
@@ -86,7 +86,7 @@ Index SparseLUImpl<Scalar, StorageIndex>::copy_to_ucol(const Index jcol, const I
           irow = glu.lsub(isub);
           glu.usub(nextu) = perm_r(irow);  // Unlike the L part, the U part is stored in its final order
           glu.ucol(nextu) = dense(irow);
-          dense(irow) = Scalar(0.0);
+          dense(irow) = Scalar(0);
           nextu++;
           isub++;
         }
diff --git a/Eigen/src/SparseLU/SparseLU_panel_bmod.h b/Eigen/src/SparseLU/SparseLU_panel_bmod.h
index 505d98297..397ad8c4d 100644
--- a/Eigen/src/SparseLU/SparseLU_panel_bmod.h
+++ b/Eigen/src/SparseLU/SparseLU_panel_bmod.h
@@ -118,7 +118,7 @@ void SparseLUImpl<Scalar, StorageIndex>::panel_bmod(const Index m, const Index w
 
         Index isub = lptr + no_zeros;
         Index off = u_rows - segsize;
-        for (Index i = 0; i < off; i++) U(i, u_col) = 0;
+        for (Index i = 0; i < off; i++) U(i, u_col) = Scalar(0);
         for (Index i = 0; i < segsize; i++) {
           Index irow = glu.lsub(isub);
           U(i + off, u_col) = dense_col(irow);
@@ -163,14 +163,14 @@ void SparseLUImpl<Scalar, StorageIndex>::panel_bmod(const Index m, const Index w
         for (Index i = 0; i < segsize; i++) {
           Index irow = glu.lsub(isub++);
           dense_col(irow) = U.coeff(i + off, u_col);
-          U.coeffRef(i + off, u_col) = 0;
+          U.coeffRef(i + off, u_col) = Scalar(0);
         }
 
         // Scatter l into SPA dense[]
         for (Index i = 0; i < nrow; i++) {
           Index irow = glu.lsub(isub++);
           dense_col(irow) -= L.coeff(i, u_col);
-          L.coeffRef(i, u_col) = 0;
+          L.coeffRef(i, u_col) = Scalar(0);
         }
         u_col++;
       }
diff --git a/Eigen/src/SparseLU/SparseLU_pivotL.h b/Eigen/src/SparseLU/SparseLU_pivotL.h
index 10a090b53..78d8fc9f9 100644
--- a/Eigen/src/SparseLU/SparseLU_pivotL.h
+++ b/Eigen/src/SparseLU/SparseLU_pivotL.h
@@ -35,7 +35,46 @@
 
 namespace Eigen {
 namespace internal {
+    template<typename Scalar, typename StorageIndex, typename std::enable_if<!std::is_same<Scalar, storm::RationalFunction>::value, int>::type = 0>
+    void findLargestAbsolutePivotElement(const Index& nsupc, const Index& nsupr, Scalar const* lu_col_ptr, StorageIndex const* lsub_ptr, Index const& diagind, Index& diag, Index& pivptr, Scalar& pivmax) {
+        Scalar rtemp = 0;
+        for (Index isub = nsupc; isub < nsupr; ++isub) {
+            rtemp = storm::utility::abs(lu_col_ptr[isub]);
+            if (rtemp > pivmax) {
+                pivmax = rtemp;
+                pivptr = isub;
+            }
+            if (lsub_ptr[isub] == diagind) diag = isub;
+        }
+    }
+
+    template<typename Scalar, typename StorageIndex, typename std::enable_if<std::is_same<Scalar, storm::RationalFunction>::value, int>::type = 0>
+    void findLargestAbsolutePivotElement(const Index& nsupc, const Index& nsupr, Scalar const* lu_col_ptr, StorageIndex const* lsub_ptr, Index const& diagind, Index& diag, Index& pivptr, Scalar& pivmax) {
+        bool foundPivotElement = false;
+        for (Index isub = nsupc; isub < nsupr; ++isub) {
+            Scalar const& rtemp = lu_col_ptr[isub];
+            if (!foundPivotElement && !storm::utility::isZero(rtemp)) {
+                foundPivotElement = true;
+                pivmax = rtemp;
+                pivptr = isub;
+            }
+            if (lsub_ptr[isub] == diagind) diag = isub;
+        }
+    }
+
+    template<typename Scalar, typename std::enable_if<std::is_same<Scalar, double>::value, int>::type = 0>
+    bool diagonalElementCanBePivot(Scalar const* lu_col_ptr, Index const& diag, Scalar const& diagpivotthresh, Scalar const& pivmax) {
+        Scalar thresh = diagpivotthresh * pivmax;
+        double rtemp = std::abs(lu_col_ptr[diag]);
+        if (!storm::utility::isZero(rtemp) && rtemp >= thresh) return true;
+        return false;
+    }
 
+    template<typename Scalar, typename std::enable_if<!std::is_same<Scalar, double>::value, int>::type = 0>
+    bool diagonalElementCanBePivot(Scalar const* lu_col_ptr, Index const& diag, Scalar const& diagpivotthresh, Scalar const& pivmax) {
+        if (!storm::utility::isZero(lu_col_ptr[diag])) return true;
+        return false;
+    }
 /**
  * \brief Performs the numerical pivoting on the current column of L, and the CDIV operation.
  *
@@ -74,40 +113,29 @@ Index SparseLUImpl<Scalar, StorageIndex>::pivotL(const Index jcol, const RealSca
 
   // Determine the largest abs numerical value for partial pivoting
   Index diagind = iperm_c(jcol);  // diagonal index
-  RealScalar pivmax(-1.0);
+  RealScalar pivmax(-1);
   Index pivptr = nsupc;
   Index diag = emptyIdxLU;
-  RealScalar rtemp;
-  Index isub, icol, itemp, k;
-  for (isub = nsupc; isub < nsupr; ++isub) {
-    using std::abs;
-    rtemp = abs(lu_col_ptr[isub]);
-    if (rtemp > pivmax) {
-      pivmax = rtemp;
-      pivptr = isub;
-    }
-    if (lsub_ptr[isub] == diagind) diag = isub;
-  }
+  Index icol, itemp, k;
+
+  findLargestAbsolutePivotElement(nsupc, nsupr, lu_col_ptr, lsub_ptr, diagind, diag, pivptr, pivmax);
 
   // Test for singularity
-  if (pivmax <= RealScalar(0.0)) {
+  bool const columnStructurallyEmpty = nsupr <= nsupc;
+  if ( columnStructurallyEmpty || storm::utility::isZero(pivmax)) {
     // if pivmax == -1, the column is structurally empty, otherwise it is only numerically zero
-    pivrow = pivmax < RealScalar(0.0) ? diagind : lsub_ptr[pivptr];
+    pivrow = columnStructurallyEmpty ? diagind : lsub_ptr[pivptr];
     perm_r(pivrow) = StorageIndex(jcol);
     return (jcol + 1);
   }
 
-  RealScalar thresh = diagpivotthresh * pivmax;
-
   // Choose appropriate pivotal element
 
   {
     // Test if the diagonal element can be used as a pivot (given the threshold value)
     if (diag >= 0) {
       // Diagonal element exists
-      using std::abs;
-      rtemp = abs(lu_col_ptr[diag]);
-      if (rtemp != RealScalar(0.0) && rtemp >= thresh) pivptr = diag;
+      if (diagonalElementCanBePivot(lu_col_ptr, diag, diagpivotthresh, pivmax)) pivptr = diag;
     }
     pivrow = lsub_ptr[pivptr];
   }
@@ -125,7 +153,7 @@ Index SparseLUImpl<Scalar, StorageIndex>::pivotL(const Index jcol, const RealSca
     }
   }
   // cdiv operations
-  Scalar temp = Scalar(1.0) / lu_col_ptr[nsupc];
+  Scalar temp = Scalar(1) / lu_col_ptr[nsupc];
   for (k = nsupc + 1; k < nsupr; k++) lu_col_ptr[k] *= temp;
   return 0;
 }
-- 
2.39.5 (Apple Git-154)

