// Taken from https://github.com/prismmodelchecker/prism/tree/master/prism-examples/imdps/consensus
// This case study is based on the shared coin protocol from the randomised consensus algorithm of Aspnes and Herlihy [AH90].
// The models here are interval MDPs which consider the effect of unreliable or adversarial behaviour in the form of a biased coin instead of a fair coin [PLSS13].

// [AH90] J. Aspnes and M. Herlihy. Fast randomized consensus using shared memory. Journal of Algorithms, 15(1):441-460, 1990.
// [PLSS13] A. Puggelli, W. Li, A. L. Sangiovanni-Vincentelli and S. A. Seshia Polynomial-Time Verification of PCTL Properties of MDPs with Convex Uncertainties In Proc. 25th International Conference on Computer Aided Verification (CAV'13), 2013.

// COIN FLIPPING PROTOCOL FOR POLYNOMIAL RANDOMIZED CONSENSUS [AH90]
// gxn/dxp 20/11/00

mdp

// constants
const int N=2;
const int K;
const int range = 2*(K+1)*N;
const int counter_init = (K+1)*N;
const int left = N;
const int right = 2*(K+1)*N - N;

// Only process 1 is biased
const double bias1;
const double bias2 = 0.0;

// shared coin
global counter : [0..range] init counter_init;

module process1

	// program counter
	pc1 : [0..3];
	// 0 - flip
	// 1 - write
	// 2 - check
	// 3 - finished

	// local coin
	coin1 : [0..1];

	// flip coin
	[] (pc1=0)  -> [0.5-bias1,0.5+bias1] : (coin1'=0) & (pc1'=1) + [0.5-bias1,0.5+bias1] : (coin1'=1) & (pc1'=1);
	// write tails -1  (reset coin to add regularity)
	[] (pc1=1) & (coin1=0) & (counter>0) -> (counter'=counter-1) & (pc1'=2) & (coin1'=0);
	// write heads +1 (reset coin to add regularity)
	[] (pc1=1) & (coin1=1) & (counter<range) -> (counter'=counter+1) & (pc1'=2) & (coin1'=0);
	// check
	// decide tails
	[] (pc1=2) & (counter<=left) -> (pc1'=3) & (coin1'=0);
	// decide heads
	[] (pc1=2) & (counter>=right) -> (pc1'=3) & (coin1'=1);
	// flip again
	[] (pc1=2) & (counter>left) & (counter<right) -> (pc1'=0);
	// loop (all loop together when done)
	[done] (pc1=3) -> (pc1'=3);

endmodule

// construct remaining processes through renaming
module process2 = process1[pc1=pc2,coin1=coin2,bias1=bias2] endmodule

// labels
label "finished" = pc1=3 & pc2=3 ;
label "all_coins_equal_0" = coin1=0 & coin2=0 ;
label "all_coins_equal_1" = coin1=1 & coin2=1 ;
label "agree" = coin1=coin2 ;

// rewards
rewards "steps"
	true : 1;
endrewards
